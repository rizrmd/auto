diff --git a/main.go b/main.go
index 900928b..e5adef2 100644
--- a/main.go
+++ b/main.go
@@ -16,6 +16,7 @@ import (
 	"os/signal"
 	"path/filepath"
 	"strings"
+	"sync"
 	"syscall"
 	"time"
 
@@ -35,11 +36,14 @@ import (
 )
 
 var (
-	client     *whatsmeow.Client
-	qrChannel  chan string
-	webhookURL string
-	isPaired   bool   = false
-	version    string = "v1.7.0"
+	client            *whatsmeow.Client
+	qrChannel         chan string
+	webhookURL        string
+	stateMutex        sync.RWMutex // Protects shared state
+	isPaired          bool   = false
+	pairingInProgress bool   = false  // Track pairing state
+	pairedDeviceID    string = ""     // Store device ID during pairing
+	version           string = "v1.7.0"
 )
 
 // Response structures for API
@@ -129,7 +133,9 @@ func initializeWhatsApp() {
 	// Check if already paired and attempt connection with better error handling
 	if client.Store.ID != nil {
 		log.Printf("Found existing session for device: %s", client.Store.ID.String())
+		stateMutex.Lock()
 		isPaired = true
+		stateMutex.Unlock()
 
 		// Attempt to connect to existing session
 		log.Println("Attempting to connect to existing session...")
@@ -142,7 +148,9 @@ func initializeWhatsApp() {
 			log.Println("   - Network connectivity issues")
 			log.Println("   - Session corruption")
 			log.Println("ðŸ’¡ Use /pair endpoint to create a new session")
+			stateMutex.Lock()
 			isPaired = false
+			stateMutex.Unlock()
 		} else {
 			log.Println("ðŸŸ¢ Successfully connected to WhatsApp with existing session")
 		}
@@ -167,7 +175,9 @@ func pairHandler(w http.ResponseWriter, r *http.Request) {
 	if client != nil && client.IsConnected() {
 		log.Println("Disconnecting existing session...")
 		client.Disconnect()
+		stateMutex.Lock()
 		isPaired = false
+		stateMutex.Unlock()
 		log.Println("Disconnected from previous session")
 	}
 
@@ -182,9 +192,6 @@ func pairHandler(w http.ResponseWriter, r *http.Request) {
 		}
 	}
 
-	// Add a small delay to ensure proper disconnection
-	time.Sleep(2 * time.Second)
-
 	// Get QR channel (must be called before connecting)
 	log.Println("Getting QR channel...")
 	qrChan, err := client.GetQRChannel(context.Background())
@@ -262,9 +269,12 @@ func handleQREvents(qrChan <-chan whatsmeow.QRChannelItem) {
 		log.Printf("QR Event: %s", evt.Event)
 		switch evt.Event {
 		case "success":
-			isPaired = true
-			log.Println("ðŸŽ‰ Successfully paired with WhatsApp!")
-			log.Printf("Device ID: %s", client.Store.ID.String())
+			// REMOVED: isPaired = true - This is now handled by Connected event
+			log.Println("ðŸŽ‰ QR code scanned successfully!")
+			log.Println("â³ Waiting for pairing handshake to complete...")
+			if client.Store.ID != nil {
+				log.Printf("Device ID: %s", client.Store.ID.String())
+			}
 		case "timeout":
 			log.Println("â° QR code pairing timed out.")
 			log.Println("ðŸ’¡ Tips: Check if WhatsApp is open on your phone and try scanning again")
@@ -306,7 +316,11 @@ func sendHandler(w http.ResponseWriter, r *http.Request) {
 	}
 
 	// Check if paired
-	if !isPaired || !client.IsConnected() {
+	stateMutex.RLock()
+	paired := isPaired
+	stateMutex.RUnlock()
+
+	if !paired || !client.IsConnected() {
 		response := APIResponse{
 			Success: false,
 			Message: "Not paired with WhatsApp. Please use /pair endpoint first",
@@ -454,9 +468,15 @@ func sendHandler(w http.ResponseWriter, r *http.Request) {
 func healthHandler(w http.ResponseWriter, r *http.Request) {
 	w.Header().Set("Content-Type", "application/json")
 
+	// Check actual device store for accurate pairing status
+	actuallyPaired := false
+	if client != nil && client.Store != nil && client.Store.ID != nil {
+		actuallyPaired = true
+	}
+
 	status := map[string]interface{}{
 		"version":            version,
-		"paired":             isPaired,
+		"paired":             actuallyPaired,
 		"connected":          client != nil && client.IsConnected(),
 		"webhook_configured": webhookURL != "",
 	}
@@ -483,9 +503,13 @@ func devicesHandler(w http.ResponseWriter, r *http.Request) {
 		return
 	}
 
+	stateMutex.RLock()
+	paired := isPaired
+	stateMutex.RUnlock()
+
 	deviceInfo := map[string]interface{}{
 		"connected": client.IsConnected(),
-		"paired":    isPaired,
+		"paired":    paired,
 	}
 
 	// Only add device info if store exists and has ID
@@ -537,7 +561,11 @@ func disconnectHandler(w http.ResponseWriter, r *http.Request) {
 		}
 	}
 
+	stateMutex.Lock()
 	isPaired = false
+	pairingInProgress = false
+	pairedDeviceID = ""
+	stateMutex.Unlock()
 
 	response := APIResponse{
 		Success: true,
@@ -632,16 +660,68 @@ func handler(rawEvt interface{}) {
 		if client.Store.ID != nil {
 			log.Printf("Device ID: %s", client.Store.ID.String())
 		}
+
+		// Check if this Connected event is after PairSuccess
+		stateMutex.Lock()
+		if pairingInProgress {
+			log.Println("âœ… Pairing completed successfully! Device is now ready.")
+			isPaired = true
+			pairingInProgress = false
+			deviceID := pairedDeviceID
+			pairedDeviceID = ""
+			stateMutex.Unlock()
+
+			// Send webhook OUTSIDE mutex to avoid blocking
+			if webhookURL != "" && deviceID != "" {
+				log.Println("ðŸ“¤ Sending pair_success webhook to backend...")
+				sendToWebhook("pair_success", fmt.Sprintf("Device paired: %s", deviceID), deviceID, "", nil)
+				log.Println("âœ… Backend notified - mobile device should complete pairing now")
+			}
+		} else {
+			stateMutex.Unlock()
+		}
 	case *events.Disconnected:
 		log.Println("ðŸ”´ Disconnected from WhatsApp")
+		stateMutex.Lock()
+		if pairingInProgress {
+			// Clear pairing state if disconnect during pairing
+			log.Println("âš ï¸ Disconnected during pairing - clearing pairing state")
+			pairingInProgress = false
+			pairedDeviceID = ""
+		}
 		isPaired = false
+		stateMutex.Unlock()
 	case *events.PairSuccess:
-		log.Printf("ðŸŽ‰ Successfully paired! Device: %s", evt.ID)
-		isPaired = true
+		log.Printf("ðŸŽ‰ Pairing handshake completed! Device: %s", evt.ID)
+		log.Println("â³ Waiting for WebSocket reconnection to complete pairing...")
+
+		stateMutex.Lock()
+		pairingInProgress = true
+		pairedDeviceID = evt.ID.String()
+		stateMutex.Unlock()
+
+		// Add timeout mechanism - if Connected event doesn't fire in 30s, clear state
+		go func(deviceID string) {
+			time.Sleep(30 * time.Second)
+			stateMutex.Lock()
+			defer stateMutex.Unlock()
+			if pairingInProgress && pairedDeviceID == deviceID {
+				log.Println("â° Pairing timeout - Connected event never received after 30s")
+				log.Println("ðŸ’¡ User may need to retry pairing")
+				pairingInProgress = false
+				pairedDeviceID = ""
+			}
+		}(evt.ID.String())
+		// DO NOT set isPaired yet - wait for Connected event
+		// DO NOT send webhook yet - wait for WebSocket reconnection to complete
 	case *events.LoggedOut:
 		log.Println("ðŸ”’ Logged out from WhatsApp")
 		log.Println("ðŸ’¡ This may happen if another device connects or if you log out from WhatsApp mobile app")
+		stateMutex.Lock()
 		isPaired = false
+		pairingInProgress = false
+		pairedDeviceID = ""
+		stateMutex.Unlock()
 	case *events.StreamError:
 		log.Printf("ðŸš« Stream error occurred")
 		log.Println("ðŸ’¡ This may indicate connection issues or device limit problems")
